import math
import os
import random
import torch
import torch.nn.functional as F

from PIL import Image
from scipy.io import loadmat
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from torchvision.transforms import functional
from zernike_psf import ZernikePSFGenerator
from general_utils import random_rotate_crop_flip, add_poisson_gaussian_noise, normalization, get_phaseZ


def get_dataloader(opt):
    if opt['dataset_name'] == 'LrAndPsfFromBioSR':
        data_set = LrAndPsfFromBioSR(opt)
    elif opt['dataset_name'] == 'LrAndPsfFromFolder':
        data_set = LrAndPsfFromFolder(opt)
    else:
        raise NotImplementedError
    loader_settings = opt['loader_settings']
    data_loader = DataLoader(data_set, batch_size=loader_settings['batch_size'],
                             shuffle=loader_settings['shuffle'], num_workers=loader_settings['num_workers'],
                             pin_memory=loader_settings['pin_memory'], drop_last=loader_settings['drop_last'])
    return data_loader


class LrAndPsfFromBioSR(Dataset):
    def __init__(self, opt):
        """
        img names in img_root should be img_xxyyy_z.png, such like img_01001_1.png, img_02789_4.png
        where z is type (CCPs | ER | Microtubules | F-actin),
        x is index of SIM_GT,
        y is index generated by data augmentation
        """
        super().__init__()
        self.is_train = opt['is_train']
        self.gpu_id = opt['gpu_id']
        if self.gpu_id is None:
            self.device = torch.device('cpu')
        else:
            self.device = torch.device('cuda', self.gpu_id)
        self.img_root = opt['img_filter']['img_root']
        self.structure_selected = tuple(opt['img_filter']['structure_selected'])
        self.included_idx = range(opt['img_filter']['included_idx'][0], opt['img_filter']['included_idx'][1] + 1)
        self.hr_cropping = opt['hr_cropping']
        self.lr_size = tuple(opt['lr_size'])
        self.img_signal = opt['img_signal']
        self.is_norm_lr = opt['is_norm_lr']
        self.is_norm_k = opt['is_norm_k']
        opt['psf_settings']['device'] = self.device
        self.phaseZ_settings = opt['psf_settings']['phaseZ']
        self.sup_phaseZ = opt['sup_phaseZ']
        self.psf_gen = ZernikePSFGenerator(opt=opt['psf_settings'])
        all_files = os.listdir(self.img_root)
        all_files.sort()
        self.names = [os.path.splitext(file)[0] for file in all_files
                      if (file.endswith('.png')
                          and (int(file.split('_')[2].replace('.png', '')) in self.structure_selected)
                          and (int(file[4:6]) in self.included_idx))]
        if not self.is_train:
            self.hrs = []
            for idx in range(len(self)):
                self.hrs.append(self.get_cropped_hr(idx))
            self.hrs = torch.cat(self.hrs, dim=-3)
            self.test_phaseZs = get_phaseZ(self.phaseZ_settings, batch_size=len(self.names), device=self.device)

            self.test_kernels = self.psf_gen.generate_PSF(phaseZ=self.test_phaseZs)
            if self.hr_cropping['mode'] == 'scanning':
                self.test_kernels = self.test_kernels.repeat(self.hr_cropping['scanning_shape'][0] * self.hr_cropping['scanning_shape'][1], 1, 1)
        else:
            self.names = self.names * opt['img_filter']['repeat']
        self.padding = opt['padding']

    def __len__(self):
        if self.hr_cropping['mode'] == 'scanning':
            return len(self.names) * self.hr_cropping['scanning_shape'][0] * self.hr_cropping['scanning_shape'][1]
        else:
            return len(self.names)

    def __getitem__(self, idx):
        if self.is_train:
            hr = self.get_cropped_hr(idx)
            phaseZ = get_phaseZ(self.phaseZ_settings, batch_size=1, device=self.device)
            kernel = self.psf_gen.generate_PSF(phaseZ=phaseZ)
        else:
            hr = self.hrs[idx:idx + 1, :, :]
            phaseZ = self.test_phaseZs[idx:idx + 1, :]
            kernel = self.test_kernels[idx:idx + 1, :, :]
        assert kernel.shape[-2] % 2 == 1 and kernel.shape[-1] % 2 == 1, 'kernel shape should be odd'
        pad = (kernel.shape[-2] // 2,) * 2 + (kernel.shape[-1] // 2,) * 2
        lr = F.conv2d(F.pad(hr.unsqueeze(0), pad=pad, mode=self.padding['mode'], value=self.padding['value']), kernel.unsqueeze(0)).squeeze(0)
        img_signal = 10.0 ** random.uniform(math.log10(self.img_signal[0]), math.log10(self.img_signal[-1]))
        lr = add_poisson_gaussian_noise(lr, level=img_signal)
        if (torch.max(lr) - torch.min(lr)) != 0.0:
            lr = normalization(lr) if self.is_norm_lr else lr / 65535.0
            if self.sup_phaseZ == 'all':
                pass
            else:
                cut_phaseZ = torch.zeros(size=phaseZ.shape, dtype=phaseZ.dtype, device=phaseZ.device)
                cut_phaseZ[..., self.sup_phaseZ[0]:self.sup_phaseZ[-1] + 1] = phaseZ[..., self.sup_phaseZ[0]:self.sup_phaseZ[-1] + 1]
                kernel = self.psf_gen.generate_PSF(phaseZ=cut_phaseZ)
            if self.is_norm_k:
                kernel = normalization(kernel)
            # lr shape: (C, H, W), kernel shape: (C, H, W)
            if self.hr_cropping['mode'] == 'scanning':
                name = self.names[idx % len(self.names)] + f' part{idx // len(self.names)}'
            else:
                name = self.names[idx]
            return {'lr': lr,
                    'hr': hr,
                    'kernel': kernel,
                    'name': name,
                    'phaseZ': phaseZ,
                    'img_signal': img_signal}
        else:
            raise RuntimeError('occur pure dark img')

    def get_cropped_hr(self, idx):
        if self.hr_cropping['mode'] == 'scanning':
            name = self.names[idx % len(self.names)]
        else:
            name = self.names[idx]
        img = Image.open(os.path.join(self.img_root, name + '.png'))
        if self.hr_cropping['mode'] == 'random':
            fill = torch.median(transforms.ToTensor()(img).float().view(-1)).item()
            while True:
                hr = transforms.ToTensor()(random_rotate_crop_flip(img, self.lr_size, fill)).float()
                # CCPs
                if int(name.split('_')[-1].replace('.png', '')) in (1, ):
                    # avoid dark regions
                    if hr.mean() >= 60:
                        break
                # ER, Microtubules, F-actin
                elif int(name.split('_')[-1].replace('.png', '')) in (2, 3, 4):
                    # avoid dark regions
                    if (torch.max(hr) - torch.min(hr)).item() >= 10000:
                        break
                else:
                    raise NotImplementedError
        elif self.hr_cropping['mode'] == 'constant':
            center_pos = self.hr_cropping['center_pos']
            bound = ((center_pos[0] - (self.lr_size[0] // 2), center_pos[0] + self.lr_size[0] - (self.lr_size[0] // 2)),
                     (center_pos[1] - (self.lr_size[1] // 2), center_pos[1] + self.lr_size[1] - (self.lr_size[1] // 2)))
            hr = transforms.ToTensor()(img).float()[..., bound[0][0]:bound[0][1], bound[1][0]:bound[1][1]]
        elif self.hr_cropping['mode'] == 'scanning':
            start_h = int((img.height - self.lr_size[0]) / self.hr_cropping['scanning_shape'][0] * (
                    (idx // len(self.names)) % self.hr_cropping['scanning_shape'][0]))
            start_w = int((img.width - self.lr_size[1]) / self.hr_cropping['scanning_shape'][1] * (
                        (idx // len(self.names)) // self.hr_cropping['scanning_shape'][0]))
            hr = transforms.ToTensor()(img).float()[..., start_h:start_h + self.lr_size[0], start_w:start_w + self.lr_size[1]]
        else:
            raise NotImplementedError('undefined mode')
        hr = hr.to(self.device)
        # hr shape: (C, H, W)
        return hr


class LrAndPsfFromFolder(Dataset):
    def __init__(self, opt):
        super().__init__()
        self.img_root = opt['img_root']
        self.lr_size = opt['lr_size']
        self.num_test_img = opt['num_test_img']
        self.is_crop = opt['is_crop']
        self.crop_center = opt['crop_center']
        all_files = os.listdir(self.img_root)
        all_files.sort()
        self.names = [os.path.splitext(file)[0] for file in all_files if file.endswith('.png')]
        if self.num_test_img >= 0:
            self.names = self.names[0:self.num_test_img]
        elif self.num_test_img == -1:
            pass
        else:
            raise NotImplementedError

    def __len__(self):
        return len(self.names)

    def __getitem__(self, idx):
        name = self.names[idx]
        lr = Image.open(os.path.join(self.img_root, name + '.png'))
        assert lr.height >= self.lr_size[0] and lr.width >= self.lr_size[1], 'img is too small'
        lr = transforms.ToTensor()(lr).float()
        if self.is_crop:
            lr = functional.crop(lr, top=self.crop_center[0] - self.lr_size[0] // 2,
                                 left=self.crop_center[1] - self.lr_size[1] // 2,
                                 height=self.lr_size[0],
                                 width=self.lr_size[1])
        # lr = add_poisson_gaussian_noise(lr, level=300.0)
        lr = normalization(lr)
        if os.path.exists(os.path.join(self.img_root, name + '.mat')):
            k_data = loadmat(os.path.join(self.img_root, name + '.mat'))
            kernel = torch.from_numpy(k_data['PSF']).unsqueeze(0)
            kernel = normalization(kernel)
        else:
            kernel = -1
        # lr的shape为(1, H, W)，kernel的shape为(1, H, W)
        return {'lr': lr, 'kernel': kernel, 'name': name}
